//ПРИСВАИВАНИЕ ОБЪЕКТОВ
let a = {};  // переменная хранит адрес ячейки в памяти - 0x10
let b = a; 	 // переменная хранит адрес ячейки в памяти - 0x10

a.foo = 'hey';
b.bar = 'loft';

console.log(a);  
console.log(b);		//обе переменные ссылаются на один объект

function fn(a) {
	a.bar = 'school'; //функция берет объект а и записывает в его свойство bar значение school
}

fn(a);  //значение а.bar перезаписано

//все вышеописанное работает и с функциями и с массивами

let c = [];
fn(c);
console.log(c);  //вернет [ bar: 'school']

let f = function() {

};
fn(f);
console.log(f); //вернет { [Function: f] bar: 'school' }


//СБОРЩИК МУСОРА (GARBAGE COLLECTOR)
let q = {}; 
let w = q;   //счетчик ссылок 2, так как на объект указывают 2 ссылки
			 //объект удаляется из памяти когда счетчик ссылок становиться равен 0

w = 0        //ссылка удалилась, стала равна 0
q = 0        //ссылок на объект больше нет, сборщик мусора удаляет объект из памяти

function fn1() {
	let e = {}
	e.foo = 'foo'; 
	e.bar = 'bar';
	e.baz = 'baz';
}            //сборщик мусора удаляет функцию из памяти, когда функция завершилась

let t = {};

function fn2(obj) {
	let r = obj;
	r.foo = 'foo'; 
	r.bar = 'bar';
	r.baz = 'baz';
	console.log(r);
}

fn2(t); //счетчик ссылок на объект становиться равен трем, так как сама функцию указывает на объект
		//после объекта все ссылки принадлещие функции удалились из памяти

let y = {};
let u = {};

if (y === u) {
	console.log('да');  //сравниваются ссылки на ячейки памяти, поэтому объекты будут не равны, и логический операто не отработает
}


//КЛОНИРОВАНИЕ ОБЪЕКОВ (Object.assign)
var i = {foo:1, bar:2};
var o = Object.assign({}, i); //клонируем свойства объекта i в объявленный пустой объект

i.bar = 100;                  //меняем свойства объекта 
console.log(i); 
console.log(o);               //значения свойст объекта o остались прежними 

vai = {foo: 1, bar:{baz: 2}}
var o = Object.assign({}, i); //Object.assign клонирует только первый уровень свойств объекта
							  //если в свойства клонируемого объекта вложен другой объект, 
							  //то склонируется только ссылка на этот объект
i.bar.baz = 100
console.log(o);               //значение свойста объекта o поменялись, посколько склонировалась ссылка на объект а не сам объект						 

var p = {foo:1, bar:2};
var s = { ...p }              //заполнение s своствами p с помощью спрэд метода


//ТИПЫ ЭЛЕМЕНТОВ В МАССИВЕ И ИХ УДАЛЕНИЕ
const obj1 = {};
obj1.foo = 123;
obj1.baz = 456;

delete obj1.foo;

console.log(obj1);

const arr1 = [123, 456, 789];
delete arr1[1]                //оставляет пустой элемент массива
console.log(arr1);    
arr1.splice(1, 1);            //таки обрпазом удаляются числовые элементы массива
console.log(arr1);
arr1.splice(1, 0, 'aaa', 'bbb', 'ccc');  //splice может быть использован для вставки новых элементов между элементами массивов
console.log(arr1);
arr1.foo = 111;
console.log(arr1);
delete arr1.foo              //однако свойство добавленное в объект удалить можно


//SET
const arr2 = [1, 2 ,3 ,4]

arr2.push(2);
arr2.push(10);
arr2.push(7);
arr2.push(2);
console.log(arr2);

if (!arr2.includes(2)) {  //примитивный метод фильтрации добавления повторяющихся элементов в массив
	arr2.push(2);
}                         

const arr3 = new Set([1,2,3,4]);  //Set следит за уникальностью добавляемых элементов

arr3.add(2);
arr3.add(2);
arr3.add(10);
arr3.add(7);
arr3.add(2);

console.log(arr3);  //нет ниодного повторяющегося значения

const g = { foo: 1 };
const d = { bar: 2 };

arr3.add(g);
arr3.add(d);

arr3.add(g);        //в Set можно добавлять любые типа данных
console.log(arr3);

//MAP
const s1 = { name: 'Andrey' };
const s2 = { name: 'Svetlana' };

const map = new Map();
map.set(s1, 4);
map.set(s2, 5);               //объект Map может принимать ссылки на другие объекты как ключи
console.log(map.get(s1));     //получить значение сохраненное в map по ключу

